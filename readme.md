Spring-потрошитель by E Borosov

# part1
add spring-contet to pom
new package quoters
new interface Quoter with void sayQuote() 
new TerminatorQuoter impl Q
property message with setter
sayQuote(){sout(message)}

идем в xml
делаем там бин TerminatorQuoter
в нем проперти со сзачением "I'll be back"

теперь надортнаписать какой-н тест
но неподключем JUnit, поэтому напишем Main
(не делайте так никогда)
созаем Main, там создаем контект из XML,
вытаскиваем бин...можно по интерфейсу,а можно по классу
^сейчас вытащим по классу, чтобы потом объяснить,чтоэто неправильно
..запускакем проверяем

/* тут описывает, как Фабрика создает объекты и складывает их в контейнер
причем если синглетоны создаются и складываются сразу, то прототайпы -только когда они нужны (лениво), отдает их и про них забывает. Поэтому при прописывании дестрой-метода для бина, он будет работать только для синглонов, т.к. прототайпы не хранятся в контейнере.

# ЧАСТЬ 2. BeanPostProcessor

при создании, перед тем как попасть в контейнер, все бины проходят через BeanPostProcessor, являя собой пример дизайн-паттерна "Chain Of Responsibility". 

Напишем свой БПП. Допутим, мы хотим кастомизировать Спринг и обучить его каким-то своим анотациям.

Представим, что мы пишем приложение, в котором очень много генерации случайных чисел, которые нужно сетить в филды. И каждый участник проекта делаетэто по-своему:кто-то матюрандом, ктоторандом.нехтИнт, ит.д..Но ируководство принимает решение, что ээтоникуда не годится,Юи теперь мы будем делать это декларативно. 
Мы придумаем аннотацию @InjectRandomInt, ибудем ставить над еми полями, в которые хотим заинжеткить рандом. 
И научим Спринг к этой аннотации относиться, и в момент создания бина настраивать его соответствующе. 

допустим унас в Терминаторе будет int repeat (сколько разонбудетповторятл цитату). Поставим на него @InjectRandomInt(min = 2, max = 7)

создадим аннотацию (
    не забываем про @Retention поменять на рантайм. По дефолту Retention стоит "класс",это означает что она попадет в рантайм, но считать через рефлекшн ее нельзя. Это нужно для AST-трансформаций, байткод-инструментирования. Пример RetentionPolicy.COMPILE это аннотация @Override, которая еужна только накомпиляции никак не попадает в байткод
)
также напишем параметры int min() и max()

ну и теперь самое интересное - нужно написать поддержку нашей аннотации.
напишем класс, который будет отвечать за нее
InjectRandomIntAnnotationBeanPostprocrssor implements BeanPostprocessor
(обратим внимание на конвеции построения названий классов)

Этот интерфейс имеет 2 метода: 
    Object postProcessBeforeInitialization(Object bean, String beanName) и  
    Object postProcessAfterInitialization(Object bean, String beanName)

первый вызывается до init-метода, второй - после.
в каждый приходит бин и его имя, и возвращаются какие-то объекты - не обязательно те же самые, которые дал BeanFactory... но мы сейчас пока вернем те же самые.

в методе ...BeforeInitiallization() возьмем все поля бина,
проитерируемся по ним, и для каждого проверим наличие @InjectRandomInt 
если !=null, возьмем min и max, и сгенерируем случайный int. 
Теперь этот int надо засунуть в это поле.
Во-первых, скорее всегополе private, значит надо сделать ему setAccessible(true)
Во-вторых надо сделать field.set().. но мы так делать не будем, т.к надо обрабатывать эксепшны. Причем мы не можемделать throws, т.к. мы имплементим чужой интерфейс (а если он не кидает Э., то и мы не можем). А try-catch некрасиво. Поэтому воспользуемся библиотекой ReflectionUtils, которая есть у Спринга, которая умеет делать всеобычные рефлекшены,но без try-catch (просто обворачивает их и прячет в RuntimeException)  

Хорошо, мы написали, акак теперьсделать, чтобы Спринг узнал про это класс?
Надо  просто прописать его в контекст. Практически все то надо добавить в Спринг, надо приписать в контекст. Можно разными способами - java, аннотацией, но раз мы с xmlnj укажем его в xml как бин (id не нужен)

..проверяем, работает



