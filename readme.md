Spring-потрошитель by E Borosov

# part1
add spring-contet to pom
new package quoters
new interface Quoter with void sayQuote() 
new TerminatorQuoter impl Q
property message with setter
sayQuote(){sout(message)}

идем в xml
делаем там бин TerminatorQuoter
в нем проперти со сзачением "I'll be back"

теперь надортнаписать какой-н тест
но неподключем JUnit, поэтому напишем Main
(не делайте так никогда)
созаем Main, там создаем контект из XML,
вытаскиваем бин...можно по интерфейсу,а можно по классу
^сейчас вытащим по классу, чтобы потом объяснить,чтоэто неправильно
..запускакем проверяем

/* тут описывает, как Фабрика создает объекты и складывает их в контейнер
причем если синглетоны создаются и складываются сразу, то прототайпы -только когда они нужны (лениво), отдает их и про них забывает. Поэтому при прописывании дестрой-метода для бина, он будет работать только для синглонов, т.к. прототайпы не хранятся в контейнере.

# ЧАСТЬ 2. BeanPostProcessor

при создании, перед тем как попасть в контейнер, все бины проходят через BeanPostProcessor, являя собой пример дизайн-паттерна "Chain Of Responsibility". 

Напишем свой БПП. Допутим, мы хотим кастомизировать Спринг и обучить его каким-то своим анотациям.

Представим, что мы пишем приложение, в котором очень много генерации случайных чисел, которые нужно сетить в филды. И каждый участник проекта делаетэто по-своему:кто-то матюрандом, ктоторандом.нехтИнт, ит.д..Но ируководство принимает решение, что ээтоникуда не годится,Юи теперь мы будем делать это декларативно. 
Мы придумаем аннотацию @InjectRandomInt, ибудем ставить над еми полями, в которые хотим заинжеткить рандом. 
И научим Спринг к этой аннотации относиться, и в момент создания бина настраивать его соответствующе. 

допустим унас в Терминаторе будет int repeat (сколько разонбудетповторятл цитату). Поставим на него @InjectRandomInt(min = 2, max = 7)

создадим аннотацию (
    не забываем про @Retention поменять на рантайм. По дефолту Retention стоит "класс",это означает что она попадет в рантайм, но считать через рефлекшн ее нельзя. Это нужно для AST-трансформаций, байткод-инструментирования. Пример RetentionPolicy.COMPILE это аннотация @Override, которая еужна только накомпиляции никак не попадает в байткод
)
также напишем параметры int min() и max()

ну и теперь самое интересное - нужно написать поддержку нашей аннотации.
напишем класс, который будет отвечать за нее
InjectRandomIntAnnotationBeanPostprocrssor implements BeanPostprocessor
(обратим внимание на конвеции построения названий классов)

Этот интерфейс имеет 2 метода: 
    Object postProcessBeforeInitialization(Object bean, String beanName) и  
    Object postProcessAfterInitialization(Object bean, String beanName)

первый вызывается до init-метода, второй - после.
в каждый приходит бин и его имя, и возвращаются какие-то объекты - не обязательно те же самые, которые дал BeanFactory... но мы сейчас пока вернем те же самые.

в методе ...BeforeInitiallization() возьмем все поля бина,
проитерируемся по ним, и для каждого проверим наличие @InjectRandomInt 
если !=null, возьмем min и max, и сгенерируем случайный int. 
Теперь этот int надо засунуть в это поле.
Во-первых, скорее всегополе private, значит надо сделать ему setAccessible(true)
Во-вторых надо сделать field.set().. но мы так делать не будем, т.к надо обрабатывать эксепшны. Причем мы не можемделать throws, т.к. мы имплементим чужой интерфейс (а если он не кидает Э., то и мы не можем). А try-catch некрасиво. Поэтому воспользуемся библиотекой ReflectionUtils, которая есть у Спринга, которая умеет делать всеобычные рефлекшены,но без try-catch (просто обворачивает их и прячет в RuntimeException)  

Хорошо, мы написали, акак теперьсделать, чтобы Спринг узнал про это класс?
Надо  просто прописать его в контекст. Практически все то надо добавить в Спринг, надо приписать в контекст. Можно разными способами - java, аннотацией, но раз мы с xmlnj укажем его в xml как бин (id не нужен)

..проверяем, работает

# ЧАСТЬ 3 init-метод

между Before и After работает init-метод
есть разные способы прописать его для бина. Если мы на аннотациях,но можно прописать аннотацию @PostConstruct
мы с XML, поэтому пропишем через аттрибут в теге <bean init-method=".."/>

зачем вообще они нужны? вроде бы есть конструктор
если в конструкторе попытатьсяползоваться чем-то,чтотнастраивает Спринг...
щас попробуем:
создадим в Терминаторе конструктор, и напечатаем в нем значение параметра repeat
он еще не проинициализировался, поэтому в нашем случае напечатает 0, а в случае объекта был бы NPE

Процесс создания объекта в Спринге лишем всякой магии: 
просканировался XML, созздались BeanDefinitions, спринг понял что надосоздать синглетон TerminatorQuoter, при помощи рефлекшна он запустил его конструктор, объект создался, ипослеэтого Спринг его настраивает. Соответственно,когдамы в конструкторе пытаемся обратиться к тому, что еще ддолден настроить Спринг - а их еще нету. Получаем либо 0, либо NPE

Поэтому вместо тогочтобы пользоваться конструктором,надо написать public void init(){sout(repeat);}
А в конструкторе будем просто печатать фразу "фаза 1". А в init() добавим "Phase 2"
(а всего рассмотрим 3 фазы конструктора)

Если просто поставить аннотацию @PostProcessor, ничего не заработает. Потому что в Контексте мы не добавили класс обработчи ктаких аннотаций. Можно прописать CommonAnnotationBeanPostProcessor, тогда заработает

(у меня аннотация @PostConstruct не знакома IDE (?)

другой способ это включить <context:annotation-config /> внутри тега <beanS>
дело в том, что кроме тех BPP,которые мы напишем сами и добавим в контекст, есть еще 5-6 уще существующих BPP, которые относятся к известынм стандартным аннотациям- @Async, @Transactional, @Scheduled, @Inject, @Autowired и т.д. Ради каждой прописывать в контекст свой BPP это дрочь, поэтому придумали неймспейсы, обычно вместо этого пишут <context:annotation-config />, и это прячет кусок XML,который добавляетв контекст все эти BPP. 
Или можно сделать <context:component-scan base-package="org.example"/> , икроме того,что просканируются пакеты, еще и добавятся в контекст все эти BPP.

подведем итоги 
(но сначала надо понять, почему личноу меня IDE не знает @PostConstruct?)
Разобрался, дело в том что автор пишет на javа8, а я на java11. аннотация @PostConstruct является частью javaEE, начиная с java9 ее убрали, поэтому надо прописать зависимость 
    
    <groupId>javax.annotation</groupId>
    <artifactId>javax.annotation-api</artifactId>
    <version>1.3.2</version>

..запускаем, все работает

