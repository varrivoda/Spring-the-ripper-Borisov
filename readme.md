Spring-потрошитель by E Borosov

# part1
add spring-contet to pom
new package quoters
new interface Quoter with void sayQuote() 
new TerminatorQuoter impl Q
property message with setter
sayQuote(){sout(message)}

идем в xml
делаем там бин TerminatorQuoter
в нем проперти со сзачением "I'll be back"

теперь надортнаписать какой-н тест
но неподключем JUnit, поэтому напишем Main
(не делайте так никогда)
созаем Main, там создаем контект из XML,
вытаскиваем бин...можно по интерфейсу,а можно по классу
^сейчас вытащим по классу, чтобы потом объяснить,чтоэто неправильно
..запускакем проверяем

/* тут описывает, как Фабрика создает объекты и складывает их в контейнер
причем если синглетоны создаются и складываются сразу, то прототайпы -только когда они нужны (лениво), отдает их и про них забывает. Поэтому при прописывании дестрой-метода для бина, он будет работать только для синглонов, т.к. прототайпы не хранятся в контейнере.

# ЧАСТЬ 2. BeanPostProcessor

при создании, перед тем как попасть в контейнер, все бины проходят через BeanPostProcessor, являя собой пример дизайн-паттерна "Chain Of Responsibility". 

Напишем свой БПП. Допутим, мы хотим кастомизировать Спринг и обучить его каким-то своим анотациям.

Представим, что мы пишем приложение, в котором очень много генерации случайных чисел, которые нужно сетить в филды. И каждый участник проекта делаетэто по-своему:кто-то матюрандом, ктоторандом.нехтИнт, ит.д..Но ируководство принимает решение, что ээтоникуда не годится,Юи теперь мы будем делать это декларативно. 
Мы придумаем аннотацию @InjectRandomInt, ибудем ставить над еми полями, в которые хотим заинжеткить рандом. 
И научим Спринг к этой аннотации относиться, и в момент создания бина настраивать его соответствующе. 

допустим унас в Терминаторе будет int repeat (сколько разонбудетповторятл цитату). Поставим на него @InjectRandomInt(min = 2, max = 7)

создадим аннотацию (
    не забываем про @Retention поменять на рантайм. По дефолту Retention стоит "класс",это означает что она попадет в рантайм, но считать через рефлекшн ее нельзя. Это нужно для AST-трансформаций, байткод-инструментирования. Пример RetentionPolicy.COMPILE это аннотация @Override, которая еужна только накомпиляции никак не попадает в байткод
)
также напишем параметры int min() и max()

ну и теперь самое интересное - нужно написать поддержку нашей аннотации.
напишем класс, который будет отвечать за нее
InjectRandomIntAnnotationBeanPostprocrssor implements BeanPostprocessor
(обратим внимание на конвеции построения названий классов)

Этот интерфейс имеет 2 метода: 
    Object postProcessBeforeInitialization(Object bean, String beanName) и  
    Object postProcessAfterInitialization(Object bean, String beanName)

первый вызывается до init-метода, второй - после.
в каждый приходит бин и его имя, и возвращаются какие-то объекты - не обязательно те же самые, которые дал BeanFactory... но мы сейчас пока вернем те же самые.

в методе ...BeforeInitiallization() возьмем все поля бина,
проитерируемся по ним, и для каждого проверим наличие @InjectRandomInt 
если !=null, возьмем min и max, и сгенерируем случайный int. 
Теперь этот int надо засунуть в это поле.
Во-первых, скорее всегополе private, значит надо сделать ему setAccessible(true)
Во-вторых надо сделать field.set().. но мы так делать не будем, т.к надо обрабатывать эксепшны. Причем мы не можемделать throws, т.к. мы имплементим чужой интерфейс (а если он не кидает Э., то и мы не можем). А try-catch некрасиво. Поэтому воспользуемся библиотекой ReflectionUtils, которая есть у Спринга, которая умеет делать всеобычные рефлекшены,но без try-catch (просто обворачивает их и прячет в RuntimeException)  

Хорошо, мы написали, акак теперьсделать, чтобы Спринг узнал про это класс?
Надо  просто прописать его в контекст. Практически все то надо добавить в Спринг, надо приписать в контекст. Можно разными способами - java, аннотацией, но раз мы с xmlnj укажем его в xml как бин (id не нужен)

..проверяем, работает

# ЧАСТЬ 3 init-метод

между Before и After работает init-метод
есть разные способы прописать его для бина. Если мы на аннотациях,но можно прописать аннотацию @PostConstruct
мы с XML, поэтому пропишем через аттрибут в теге <bean init-method=".."/>

зачем вообще они нужны? вроде бы есть конструктор
если в конструкторе попытатьсяползоваться чем-то,чтотнастраивает Спринг...
щас попробуем:
создадим в Терминаторе конструктор, и напечатаем в нем значение параметра repeat
он еще не проинициализировался, поэтому в нашем случае напечатает 0, а в случае объекта был бы NPE

Процесс создания объекта в Спринге лишем всякой магии: 
просканировался XML, созздались BeanDefinitions, спринг понял что надосоздать синглетон TerminatorQuoter, при помощи рефлекшна он запустил его конструктор, объект создался, ипослеэтого Спринг его настраивает. Соответственно,когдамы в конструкторе пытаемся обратиться к тому, что еще ддолден настроить Спринг - а их еще нету. Получаем либо 0, либо NPE

Поэтому вместо тогочтобы пользоваться конструктором,надо написать public void init(){sout(repeat);}
А в конструкторе будем просто печатать фразу "фаза 1". А в init() добавим "Phase 2"
(а всего рассмотрим 3 фазы конструктора)

Если просто поставить аннотацию @PostProcessor, ничего не заработает. Потому что в Контексте мы не добавили класс обработчи ктаких аннотаций. Можно прописать CommonAnnotationBeanPostProcessor, тогда заработает

(у меня аннотация @PostConstruct не знакома IDE (?))

другой способ это включить <context:annotation-config /> внутри тега <beanS>
дело в том, что кроме тех BPP,которые мы напишем сами и добавим в контекст, есть еще 5-6 уще существующих BPP, которые относятся к известынм стандартным аннотациям- @Async, @Transactional, @Scheduled, @Inject, @Autowired и т.д. Ради каждой прописывать в контекст свой BPP это дрочь, поэтому придумали неймспейсы, обычно вместо этого пишут <context:annotation-config />, и это прячет кусок XML,который добавляетв контекст все эти BPP. 
Или можно сделать <context:component-scan base-package="org.example"/> , икроме того,что просканируются пакеты, еще и добавятся в контекст все эти BPP.

подведем итоги 
(но сначала надо понять, почему личноу меня IDE не знает @PostConstruct?)
Разобрался, дело в том что автор пишет на javа8, а я на java11. аннотация @PostConstruct является частью javaEE, начиная с java9 ее убрали, поэтому надо прописать зависимость 
    
    <groupId>javax.annotation</groupId>
    <artifactId>javax.annotation-api</artifactId>
    <version>1.3.2</version>

..запускаем, все работает

# ЧАСТЬ 4, postProcessor AFTER init

Так зачем же 2 прохода по BeanPostProcessor'ам? 
напишем ПостПроцессор, который будет делать профайлинг, который можно будет отключать через JMX-console

Другими словами, мы хотим, чтобы профилировались все классы, над которыми стоит аннотация @Profiling (сделаем её). Тоесть,выводилось время, за которое метод работает. 

То есть последовательность такая: у нас будет BeanPostProcessor, который будет получать bean от фабрики, спрашивать - не стоит ли над классом аннотация, если да, то ему придется в каждый метод данного бина дописывать логику профайлинга. Сама логига не сложная: запомнить время до,запустить метод, замерить после окончания, разницу вывести на экран. Но как добавитьлогику в объект? 

В Java нужно будет налету сгенерировать новый класс. Какой это должен быть класс? Очевидно такой, чтобы никто не заметил подмены. Поэтому новый класс,который сгенерится налету, должен либо наследоваться от ориг класса,
либо имплементировать его интерфейсы. 
Перый подход - CGLIB, второй - DynamicProxy. CGLIB считается,что хуже, т.к. не получится отнаследовать FINAL методы и классы, и к тому же работает медленнее. Поэтому Спринг всегда предпочитает идти через интерфейсы. Кстаи, через И работают и аспекты (^Спринг АОП) Еслиже нет интерфейсов,то Спринг идет через CGLIB (кстати, cglib сейчас есть почти во всех проектах)

Итак, если наш БПП будет подменять класс, то что будетв нашем Бпп, который рассчитывает искллючительно на то что getClass() вернет оригттнальныйкласс,в котором всеполя аннотированы ориг аннотиями? Класскоторый сгенерится на лету, никакой метадаты там нетбудлет,никааихаанотаций. Аннотацияф @Inherited не поможет. Есть конечно AOPUtils, но с ними возникают ращличные сложности... Поэтомуправильно,и по конвенция Спригна, нужно не смешивать, а делать все прокси вещи на этапе postProcessAfterInitialization()юэто даетнам уверенность,что @PostConstruct всегда работает на оригинальный метод,  дотого как всепрокси на него накрутились.

создадим класс ProfilingHandkerBeanPostProcessor
внем мапу<стринг,класс>  с именем бина...кстати имябина всегда сохраняется. Поэтому один изспособов- это на этапе BEFORE откладывать в сторонку,запоминать имена техбинов,для которых чтото надо сделать,а на этапе AFTER делать это

в BEFORE возвращаем бин, а перед этим вытащим у него getClass(), и если этот класс аннотирован @Proifiling то кладем этот класс в мапу по имени (приходитв BEFORE)

а на этапе AFTER вытаскиваем из мапы бинКласс по имени (приходит в AFTER), и если этот бинКласс !=null,значит мы егозапомнили, значит над  ним стояла аанотация,и значит надотвозвращать не оригбин, а прокси. Как? Rcxfcnm.?yfv самим не придется генерить класс на лету, с 1999 годавджаве есть dynamic proxy.

retirn Proxy.newProxyInstance(...) -принимает класслоадер (возьмем из бинКласса) списокинтерфейсов и InvocationHandler - объекткоторый инкапс логику,котораябызывает исходный метод и модифицирует его new InvoHandler(..) { тут можно сделать какие-то деиствия, и вернуть принимаемыйМетод.invoke() }








